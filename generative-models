<html>
  <head>
    <title>ProbMods: Generative Models</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
<body>
<div id="nav">
<h1>Navigation</h1>
<ol>
<li><a href='generative-models'>Generative Models</a></li>
<li><a href='conditioning'>Conditioning</a></li>
</ol>
</div>

<div id="chapter">
<h1 id="defining-simple-generative-models"><a href="#defining-simple-generative-models">Defining Simple Generative Models</a></h1>
<p>As our formal model of computation we start with the λ-calculus, and its embodiment in the LISP family of programming languages. The λ-calculus is a formal system which was invented by Alonzo Church in the 1920's.[1] Church introduced the λ-calculus as a model and formalization of computation, that is, as a way of formalizing the notion of an effectively computable function. The lambda calculus is a universal model of computation—it is conjectured to be equivalent to all other notions of classical computation (the λ-calculus was shown to have the same computational power as the Turing machine and vice versa by Alan Turing in his famous paper which introduced the Turing machine). It is remarkable that the λ-calculus is universal because it has only two basic operations: creating and applying functions.</p>
<p>In 1958 John McCarthy introduced LISP (<em>LIS</em>t <em>P</em>rocessing), a programming language based on the λ-calculus.[2] Scheme is a variant of LISP developed by Guy L. Steele and Gerald Jay Sussman with particularly simple syntax and semantics.[3] (For a simple tutorial on the Scheme language, see [1] or [2].)</p>
<p>We will use Scheme-style notation for the λ-calculus in this tutorial. The Church programming language - named in honor of Alonzo Church - is a generalization of Scheme which introduces the notion of probabilistic computation to the language. In the next few sections of this tutorial, we introduce the basics of Church programming and show how to use it to build generative models.</p>
<p>The λ-calculus formalizes the notion of computation using functions. Computation is performed in the λ-calculus by applying functions to arguments to compute results. Function application in Church looks like this:</p>
<p>Some math:</p>
<p><span class="math">\(\alpha^\beta \sim \prod_i{p_i(d_i \mid h)}\)</span></p>
<pre class="bher"><code>snap blah blah
multiple lines
   indentation</code></pre>
<table class="sourceCode haskell numberLines" id="mycode" startFrom="100"><tr class="sourceCode"><td class="lineNumbers"><pre>100
101
102
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort (<span class="fu">filter</span> (<span class="fu">&lt;</span> x) xs) <span class="fu">++</span> [x] <span class="fu">++</span>
               qsort (<span class="fu">filter</span> (<span class="fu">&gt;=</span> x) xs)</code></pre></td></tr></table>
<p>Something something, a citation <span class="citation" data-cites="Goodman:2008p865">Goodman et al. (2008)</span></p>
<p>blah blah further</p>
<p>As our formal model of computation we start with the λ-calculus, and its embodiment in the LISP family of programming languages. The λ-calculus is a formal system which was invented by Alonzo Church in the 1920's.[1] Church introduced the λ-calculus as a model and formalization of computation, that is, as a way of formalizing the notion of an effectively computable function. The lambda calculus is a universal model of computation—it is conjectured to be equivalent to all other notions of classical computation (the λ-calculus was shown to have the same computational power as the Turing machine and vice versa by Alan Turing in his famous paper which introduced the Turing machine). It is remarkable that the λ-calculus is universal because it has only two basic operations: creating and applying functions.</p>
<p>As our formal model of computation we start with the λ-calculus, and its embodiment in the LISP family of programming languages. The λ-calculus is a formal system which was invented by Alonzo Church in the 1920's.[1] Church introduced the λ-calculus as a model and formalization of computation, that is, as a way of formalizing the notion of an effectively computable function. The lambda calculus is a universal model of computation—it is conjectured to be equivalent to all other notions of classical computation (the λ-calculus was shown to have the same computational power as the Turing machine and vice versa by Alan Turing in his famous paper which introduced the Turing machine). It is remarkable that the λ-calculus is universal because it has only two basic operations: creating and applying functions.</p>
<p>As our formal model of computation we start with the λ-calculus, and its embodiment in the LISP family of programming languages. The λ-calculus is a formal system which was invented by Alonzo Church in the 1920's.[1] Church introduced the λ-calculus as a model and formalization of computation, that is, as a way of formalizing the notion of an effectively computable function. The lambda calculus is a universal model of computation—it is conjectured to be equivalent to all other notions of classical computation (the λ-calculus was shown to have the same computational power as the Turing machine and vice versa by Alan Turing in his famous paper which introduced the Turing machine). It is remarkable that the λ-calculus is universal because it has only two basic operations: creating and applying functions.</p>
<p>As our formal model of computation we start with the λ-calculus, and its embodiment in the LISP family of programming languages. The λ-calculus is a formal system which was invented by Alonzo Church in the 1920's.[1] Church introduced the λ-calculus as a model and formalization of computation, that is, as a way of formalizing the notion of an effectively computable function. The lambda calculus is a universal model of computation—it is conjectured to be equivalent to all other notions of classical computation (the λ-calculus was shown to have the same computational power as the Turing machine and vice versa by Alan Turing in his famous paper which introduced the Turing machine). It is remarkable that the λ-calculus is universal because it has only two basic operations: creating and applying functions.</p>
<p>Goodman, Noah D., Joshua B. Tenenbaum, Jacob Feldman, and Thomas L. Griffiths. 2008. “A rational analysis of rule-based concept learning.” <em>Cognitive Science</em>.</p>
</div>
</body>
</html>